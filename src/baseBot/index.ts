import { DB, dbUser, User } from "../db.js";
import { Formatter } from "./formatter.js";
import { actionsInfo, MsgAnalyser } from "./msgAnalyser/index.js";
import { texts } from "./texts.js";
import { Day, pairsGetDateOptions, pairsGetTargetOptions, SchApi } from "node-sch-api";
import { Monday } from "../utils/monday.js";
import { Logger } from "../logger.js";
import { platforms, PlatformSpecificBot } from "../platforms/index.js";

export class Bot {
	constructor(
		public msgAnalyser: MsgAnalyser,
		public schapi: SchApi,
		public db: DB,
		public logger: Logger,
	) { }

	async router(request: { text: string, from: string } | { start: true, from: string }, getUser: getUser) {
		let text = ''

		try {
			if ('start' in request) {
				// –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–¥
				await getUser()

				return text = texts.shortHelp
			}

			const analyseRes = this.msgAnalyser.analyse(request.text)
			if (!analyseRes) {
				return text = '‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–æ–º–∞–Ω–¥—É'
			}

			if (!analyseRes.allUsed) {
				text += `‚ÑπÔ∏è –í—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–π –∑–∞–ø—Ä–æ—Å: ${analyseRes.chunks.filter(item => item.used).map(item => item.text).join(' ')}\n\n`
			}

			let handlerReturn: string
			switch (analyseRes.action) {
				case "cmd":
					handlerReturn = await this.cmdHandler(analyseRes.info as actionsInfo['cmd'], getUser)
					break

				case "sub":
					handlerReturn = await this.subHandler(analyseRes.info as actionsInfo['sub'], getUser)
					break

				case "search":
					handlerReturn = await this.searchHandler(analyseRes.info as actionsInfo['search'], getUser)
					break

				case "feedback":
					const { text } = analyseRes.info as actionsInfo['feedback']

					handlerReturn = await this.feedbackHandler(text, request.from)
					break
			}

			text += handlerReturn

			return text
		} catch (e) {
			console.error(e)
			this.logger.logToChat('–±–æ—Ç. –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞', e)

			return text = '‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'
		} finally {
			this.logger.dumpRequest(
				JSON.stringify(request),
				text,
			)
		}
	}

	async cmdHandler(info: actionsInfo['cmd'], getUser: getUser): Promise<string> {
		switch (info.cmd) {
			case "bells":
				return texts.bells

			case "help":
				return texts.largeHelp

			case "format":
				const newFormat = await (await getUser()).switchFormat()
				return '‚ÑπÔ∏è –§–æ—Ä–º–∞—Ç –æ–±–Ω–æ–≤–ª—ë–Ω\n–°–ø–∏—Å–æ–∫ —Ñ–æ—Ä–º–∞—Ç–æ–≤:\n' + Formatter.makeTextListOfFormats(newFormat)

			case "mute":
				const newState = await (await getUser()).toggleMute()
				return '‚ÑπÔ∏è –†–∞—Å—Å—ã–ª–∫–∞ ' + ((newState) ? '–≤–∫–ª—é—á–µ–Ω–∞' : '–æ—Ç–∫–ª—é—á–µ–Ω–∞')

			case "optout":
				await (await getUser()).wipe()
				return '‚ÑπÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ä–∞—Å—Å—ã–ª–æ–∫ —Å–±—Ä–æ—à–µ–Ω—ã'

			case "stats":
				const updates = await this.schapi.updates.get(new Monday())
				return '‚ÑπÔ∏è –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Ç–µ–∫—É—â—É—é –Ω–µ–¥–µ–ª—é –¥–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è —Å–ª–µ–¥—É—é—â–∏—Ö —Ñ–∞–∫—É–ª—å—Ç–µ—Ç–æ–≤: ' + updates.map(item => item.faculty_short).join(', ')
		}
	}

	async subHandler(info: actionsInfo['sub'], getUser: getUser): Promise<string> {
		if (!info.target) {
			return '‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ü–µ–ª—å –ø–æ–¥–ø–∏—Å–∫–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–æ—Ä–º–∞—Ç –≥—Ä—É–ø–ø—ã (–ø—Ä–∏–º–µ—Ä—ã –≤–µ—Ä–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞: 430–±, 1-23–º, 123—Å, 123–±-–∞) –∏–ª–∏ —É–∫–∞–∂–∏—Ç–µ –ø–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å (–ø—Ä–∏–º–µ—Ä –ø–æ–ª–Ω–æ–π –∫–æ–º–∞–Ω–¥—ã: –ø–æ–¥–ø–∏—à–∏ –ø–æ–∏—Å–∫ –∏–≤–∞–Ω–æ–≤)'
		}
		const { target } = info

		const user = await getUser()

		switch (target.type) {
			case "group":
				const { available } = await this.schapi.groups.test(target.value)

				await user.setGroup(target.value)
				return ((available) ? '' : '‚ö†Ô∏è –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–π –≥—Ä—É–ø–ø—ã —Ä–∞–Ω–µ–µ –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –ø—É–±–ª–∏–∫–æ–≤–∞–ª–æ—Å—å. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –≤–≤–æ–¥–∞\n\n') + makeText(user)

			case "query":
				const valRes = Bot.validateQuery(target.value)
				if (valRes !== true) {
					return valRes
				}

				await user.setQuery(target.value)
				return makeText(user)
		}

		function makeText(user: User) {
			const group = (user.group_name) ? `"${user.group_name}"` : '–Ω–µ—Ç –ø–æ–¥–ø–∏—Å–∫–∏'
			const query = (user.query) ? `"${user.query}"` : '–Ω–µ—Ç –ø–æ–¥–ø–∏—Å–∫–∏'
			const mailingStatus = (user.notify) ? '–≤–∫–ª—é—á–µ–Ω–∞' : '–æ—Ç–∫–ª—é—á–µ–Ω–∞'
			return `‚ÑπÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã\n–¢–µ–∫—É—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:\n\n–ì—Ä—É–ø–ø–∞: ${group}\n–ü–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å: ${query}\n–†–∞—Å—Å—ã–ª–∫–∞: ${mailingStatus}`
		}
	}
	static validateQuery(query: string) {
		if (query.length < 3) {
			return '‚ö†Ô∏è –ü–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –∫–æ—Ä–æ—á–µ 3 —Å–∏–º–≤–æ–ª–æ–≤'
		}

		let specialSymbolsCount = 0
		for (let i = 0; i < query.length; i++) {
			if (query[i] === '_' || query[i] === '%') {
				specialSymbolsCount++
			}
		}
		if (specialSymbolsCount / query.length > 0.25) {
			return '‚ö†Ô∏è –°–ª–∏—à–∫–æ–º –æ–±—â–∏–π –∑–∞–ø—Ä–æ—Å. –ö–æ–ª-–≤–æ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª—å—à–µ —á–µ—Ç–≤–µ—Ä—Ç–∏ –¥–ª–∏–Ω—ã —Å—Ç—Ä–æ–∫–∏'
		}

		return true
	}

	async searchHandler(info: actionsInfo['search'], getUser: getUser): Promise<string> {
		let targets = {
			group: null as string | null,
			query: null as string | null,
		}

		if (info.target) {
			targets[info.target.type] = info.target.value
		}

		let text = ''
		if (targets.query?.match(MsgAnalyser.groupRegexp)) {
			text += '‚ö†Ô∏è –ü–æ—Ö–æ–∂–µ, –≤—ã –∏—â–µ—Ç–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã. –ï—Å–ª–∏ —ç—Ç–æ —Ç–∞–∫, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑, –Ω–æ –±–µ–∑ —Å–ª–æ–≤–∞ "–ø–æ–∏—Å–∫"\n\n'
		}

		const user = await getUser()

		// –µ—Å–ª–∏ —Ü–µ–ª—å –∑–∞–ø—Ä–æ—Å–∞ –Ω–µ –±—ã–ª–∞ —è–≤–Ω–æ —É–∫–∞–∑–∞–Ω–∞
		if (!(targets.group || targets.query)) {
			// –µ—Å–ª–∏ –ø–æ–¥–ø–∏—Å–æ–∫ —Ç–∞–∫–∂–µ –Ω–µ—Ç
			if (!(user.group_name || user.query)) {
				return '‚ö†Ô∏è –ù–µ—Ç —Ü–µ–ª–∏ –∑–∞–ø—Ä–æ—Å–∞. –£–∫–∞–∂–∏—Ç–µ —Ü–µ–ª—å (–≥—Ä—É–ø–ø—É –∏–ª–∏ –ø–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å), –ª–∏–±–æ –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É'
			}

			targets.group = user.group_name
			targets.query = user.query
		}

		const dateOptions: pairsGetDateOptions = {
			date: info.date,
			week: info.week,
		}

		const makeResponse = async (title: string, targetOptions: pairsGetTargetOptions) => {
			let text = `üìå ${title}\n\n`

			const daysInfo = await this.schapi.pairs.confirmableGet(Object.assign(targetOptions, dateOptions))
			if (!daysInfo.available) {
				return text + '‚ö†Ô∏è –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–π –∑–∞–ø—Ä–æ—Å—É –Ω–µ–¥–µ–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ'
			}
			let { days } = daysInfo

			if (dateOptions.week) {
				const monday = new Monday(dateOptions.date)

				// —Å–æ–∑–¥–∞—Ç—å –º–∞—Å—Å–∏–≤ —Ç–æ–ª—å–∫–æ –∏–∑ –ø—É—Å—Ç—ã—Ö –¥–Ω–µ–π
				let filledDays = new Array<Day>(6)

				// –∑–∞–ø–æ–ª–Ω–∏—Ç—å –µ–≥–æ –∏–º–µ—é—â–∏–º–∏—Å—è –¥–Ω—è–º–∏
				for (const day of days) {
					const dayIndex = day.date.getDay() - 1

					filledDays[dayIndex] = day
				}

				// –∑–∞–ø–æ–ª–Ω–∏—Ç—å –æ–∫–Ω–∞ –¥–Ω—è–º–∏ –±–µ–∑ –ø–∞—Ä
				for (let i = 0; i < 6; i++) {
					const day = filledDays[i]

					if (day) {
						continue
					}

					const date = new Date(monday.date)
					date.setDate(monday.date.getDate() + i)

					filledDays[i] = {
						date,
						pairs: [],
					}
				}

				days = filledDays
			}

			return text + Formatter.formatDays(days, user.format) + '\n'
		}

		// –¥–æ–±–∞–≤–∏—Ç—å –æ—Ç–≤–µ—Ç –ø–æ –≥—Ä—É–ø–ø–µ
		if (targets.group) {
			text += await makeResponse(`–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã ${targets.group}`, { groupName: targets.group })
		}

		// –¥–æ–±–∞–≤–∏—Ç—å –æ—Ç–≤–µ—Ç –ø–æ –ø–æ–∏—Å–∫–æ–≤–æ–º—É –∑–∞–ø—Ä–æ—Å—É
		if (targets.query) {
			text += await makeResponse(`–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –ø–æ –∑–∞–ø—Ä–æ—Å—É "${targets.query}"`, { query: targets.query })
		}

		return text
	}

	async feedbackHandler(text: string, sender: string): Promise<string> {
		if (text.length === 0) {
			return '‚ö†Ô∏è –ß—Ç–æ–±—ã –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤, –Ω—É–∂–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç—å —Å–ª–æ–≤–æ "–æ—Ç–∑—ã–≤" –∏ –ø–æ—Å–ª–µ –Ω–µ–≥–æ —Ç–µ–∫—Å—Ç, –∫–æ—Ç–æ—Ä—ã–π –≤—ã —Ö–æ—Ç–∏—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å'
		}

		this.logger.logToChat(`–æ—Ç–∑—ã–≤ –æ—Ç ${sender}\n${text}`)

		return '‚ÑπÔ∏è –û—Ç–∑—ã–≤ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω'
	}

	async startMailing(sendFuncs: { [key in platforms]: PlatformSpecificBot['mailingSend'] }, nextday: boolean) {
		const date = new Date()
		if (nextday) {
			date.setDate(date.getDate() + 1)
		}

		const updates = await this.schapi.updates.get(new Monday(date))
		// –Ω–µ –¥–µ–ª–∞—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É, –µ—Å–ª–∏ –Ω–∏–∫–∞–∫–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–æ
		if (updates.length === 0) {
			return
		}

		const title = `${(nextday) ? 'üìó' : 'üìï'} –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–∞–Ω—è—Ç–∏–π –Ω–∞ ${(nextday) ? '–∑–∞–≤—Ç—Ä–∞' : '—Å–µ–≥–æ–¥–Ω—è'}`

		// –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, —É –∫–æ—Ç–æ—Ä—ã—Ö –≤–∫–ª—é—á–µ–Ω–∞ —Ä–∞—Å—Å—ã–ª–∫–∞
		const users = await User.getAllSubs(this.db.pool)

		// –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∏ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–∞—Ä—Ç –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫ –∏ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –Ω–∏–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
		const subsOfGroup = new Map<string, dbUser[]>()
		const subsOfQuery = new Map<string, dbUser[]>()

		for (const user of users) {
			if (user.group_name) {
				const groupSub = subsOfGroup.get(user.group_name)
				if (groupSub) {
					groupSub.push(user)
				} else {
					subsOfGroup.set(user.group_name, [user])
				}
			}

			if (user.query) {
				const querySub = subsOfQuery.get(user.query)
				if (querySub) {
					querySub.push(user)
				} else {
					subsOfQuery.set(user.query, [user])
				}
			}
		}

		// –∑–∞–ø—Ä–æ—Å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –ø–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã–º –ø–æ–¥–ø–∏—Å–∫–∞–º
		const pairsOfAllSubs = await this.schapi.pairs.confirmableBulkGet(
			date,
			{
				groupName: Array.from(subsOfGroup.keys()),
				query: Array.from(subsOfQuery.keys()),
			},
		)


		type pairsInfo = typeof pairsOfAllSubs['query'] extends Map<any, infer I> ? I : never
		type targetAndPairsInfoTuple = [string, pairsInfo]
		type userPairsInfo = { query: targetAndPairsInfoTuple, groupName: targetAndPairsInfoTuple }
		const bothSubsUsers = new Map<dbUser, userPairsInfo>()
		function getUserPairsInfo(dbuser: dbUser) {
			let t = bothSubsUsers.get(dbuser)
			if (!t) {
				t = { query: ['', { available: false }], groupName: ['', { available: false }] }
				bothSubsUsers.set(dbuser, t)
			}

			return t
		}

		// –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏ —Ä–∞—Å—Å—ã–ª–∫–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
		const tasks: Promise<any>[] = []
		const errors: unknown[] = []
		const send = (user: dbUser, text: string) => sendFuncs[user.platform](user.id, text).catch(e => { errors.push(e) })
		const subtitleByGroupName = (groupName: string) => `üìå –ì—Ä—É–ø–ø–∞ ${groupName}:`
		const subtitleByQuery = (query: string) => `üìå –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ –ø–æ "${query}":`

		for (const [group, pairsInfo] of pairsOfAllSubs.groupName) {
			const users = subsOfGroup.get(group) ?? []

			const cacheByFormat = new Array<string>(Formatter.presets.length)
			for (const user of users) {
				// –µ—Å–ª–∏ –¥–≤–µ –ø–æ–¥–ø–∏—Å–∫–∏, —Ç–æ —Ç–æ–ª—å–∫–æ –∑–∞–Ω–µ—Å—Ç–∏ –¥–∞–Ω–Ω—ã–µ
				if (user.query) {
					getUserPairsInfo(user).groupName = [group, pairsInfo]

					continue
				}

				if (!pairsInfo.available) {
					continue
				}

				// –µ—Å–ª–∏ —Ä–∞—Å—Å—ã–ª–∫–∞ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è –∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –ø—É—Å—Ç–æ–µ
				if (!nextday && pairsInfo.pairs.length === 0) {
					continue
				}

				let text = cacheByFormat[user.format]
				if (!text) {
					text = `${title}\n\n${subtitleByGroupName(group)}\n${Formatter.formatPairs(pairsInfo.pairs, user.format)}`
					cacheByFormat[user.format] = text
				}

				tasks.push(send(user, text))
			}
		}

		for (const [query, pairsInfo] of pairsOfAllSubs.query) {
			const users = subsOfQuery.get(query) ?? []

			const cacheByFormat = new Array<string>(Formatter.presets.length)
			for (const user of users) {
				if (user.group_name) {
					getUserPairsInfo(user).query = [query, pairsInfo]

					continue
				}

				if (!pairsInfo.available) {
					// –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ, —Ç.–∫. –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –≤ –∞–ø–∏ –ø–æ–º–µ—á–∞–µ—Ç—Å—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ –Ω–∏ –¥–ª—è –æ–¥–Ω–æ–≥–æ —Ñ–∞–∫—É–ª—å—Ç–µ—Ç–∞
					// —Ç–∞–∫–∏–µ —Å–ª—É—á–∞–∏ –æ—Ç—Å–µ–∫–∞—é—Ç—Å—è –≤ –Ω–∞—á–∞–ª–µ —Ñ—É–Ω–∫—Ü–∏–∏
					const warnText = '—Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –ø–æ–ª—É—á–µ–Ω–æ, –Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ –≤ –ø–æ–¥–ø–∏—Å–∫–∞—Ö –ø–æ–∏—Å–∫–∞'
					console.warn(warnText)
					errors.push(warnText)

					continue
				}

				// –µ—Å–ª–∏ —Ä–∞—Å—Å—ã–ª–∫–∞ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è –∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –ø—É—Å—Ç–æ–µ
				if (!nextday && pairsInfo.pairs.length === 0) {
					continue
				}

				let text = cacheByFormat[user.format]
				if (!text) {
					text = `${title}\n\n${subtitleByQuery(query)}\n${Formatter.formatPairs(pairsInfo.pairs, user.format)}`
					cacheByFormat[user.format] = text
				}

				tasks.push(send(user, text))
			}
		}

		for (const [user, userPairsInfo] of bothSubsUsers) {
			const [groupName, groupNamePairsInfo] = userPairsInfo.groupName
			const [query, queryPairsInfo] = userPairsInfo.query

			const availByGroupName = groupNamePairsInfo.available
			const availByQuery = queryPairsInfo.available
			// –µ—Å–ª–∏ –æ–±–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã
			if (!availByGroupName && !availByQuery) {
				continue
			}

			const fullByGroupName = availByGroupName && groupNamePairsInfo.pairs.length > 0
			const fullByQuery = availByQuery && queryPairsInfo.pairs.length > 0
			// –µ—Å–ª–∏ —Ä–∞—Å—Å—ã–ª–∫–∞ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è –∏ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –ª—É—á—à–µ –ø—É—Å—Ç–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –Ω–µ—Ç
			if (!nextday && !(fullByGroupName || fullByQuery)) {
				continue
			}

			const text = title + '\n\n' + makeText(groupNamePairsInfo, subtitleByGroupName(groupName)) + makeText(queryPairsInfo, subtitleByQuery(query))

			tasks.push(send(user, text))
			

			function makeText(pairsInfo: pairsInfo, subtitle: string) {
				let body = ''

				if (!pairsInfo.available) {
					body = '‚ö†Ô∏è –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ'
				} else {
					body = Formatter.formatPairs(pairsInfo.pairs, user.format)
				}

				return `${subtitle}\n${body}\n`
			}
		}

		await Promise.allSettled(tasks)
		errors.forEach(error => console.error(error))
		if (errors.length > 0) {
			this.logger.logToChat('–±–æ—Ç. —Ä–∞—Å—Å—ã–ª–∫–∞. –∫–æ–ª-–≤–æ –æ—à–∏–±–æ–∫: ' + errors.length)
		}
	}
}

type getUser = () => Promise<User>
